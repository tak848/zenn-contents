---
title: "PDFの内部構造を独自XML風に表現してよくある現象まで理解する"
emoji: "📄"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["PDF"]
published: false
publication_name: layerx
---

![PDFの内部構造を独自XML風に表現してよくある現象まで理解する](/images/20251218-pdf-xml/ogp.png)

## はじめに

[LayerX Tech Advent Calendar](https://layerx.notion.site/6975c0901ea54ca9b609fafc3e8a35c3?v=2bccdd370bae80579556000cc2afc504) の 18 日目の記事です。

今年の 4 月に新卒として入社し、先月からバクラク事業部の Payment 開発部で新規事業の開発をしています。[@tak848](https://github.com/TAK848)です。最近は「takのPDF」という謎Slackスタンプを押されることが増えました。

みなさん、最近はAIのツールの台頭もあってPDFの書類や本をよく手にするようになったと思いますが、そもそもそのPDF の内部構造って意識したことありますか？
PDF があるととりあえず色んなツールで作成したり編集したり閲覧したり、変換したりと十人十色の操作をしますが、PDF の内部構造をちゃんと意識したことって意外と少ないのでは？と思っています。

直近の社内LTのネタを考える中で、PDFのオブジェクトは木構造風に表せることを思い出し、PDFをXML風に表して伝えれば皆に理解してもらいやすくなるのでは！と思い社内で発表しました。
この記事ではそのLTを肉付けし、HTML のような XML 形式ならちょっと分かる！けど PDF の構造なんて考えたことも調べたことも無かった！という方向けに、PDF ファイルを独自のオレオレXMLとして表して、内部構造からあるある現象までを理解できることを目指します。

最近はとにかく話題が AIだらけ ですが、たまには PDF という枯れた技術にも目を向けていきましょう！

:::message
この記事では、内部の構造が読みやすいように構造を簡略化したり、厳密なデータ表現から変えたりしている箇所があります。  
「仕様レベルの正確さで読みたい」方向けには [PDF の仕様についてもっと知りたくなったら](#pdf-の仕様についてもっと知りたくなったら) に参考資料を置いています。
:::

## この記事で触れること / 触れないこと

### 触れる

- PDF がどんな部品でできているかをつかむ
- 参照関係を辿ると木構造っぽく見えることをつかむ
- XML 風に表して読んでみる
- よくある現象（OCR、黒塗り、テキスト抽出の違和感）がなぜ起きるかを内部構造から理解できる

### 触れない

- PDF の仕様を網羅的に解説・理解する
- PDF のバージョンごとの差違について深掘りする
- PDF のパーサやレンダラを実装する
- 署名、フォーム、注釈、添付ファイルやメタデータなどの様々なObjectについて深掘りする

## まずは部品を見る

PDF はバイナリ形式のファイルです。  
ただし、オブジェクト番号・辞書（`<< >>`）・参照（`n n R`）・`xref` や `trailer` といった骨格はテキストで書かれています。条件がそろうと、エディタで読めそうに見えることもあります。

とはいえ実際の PDF では、ストリームが全体的に圧縮されていたり、オブジェクトをまとめて格納されていたりします。そのため、素のまま読むのは難しいことが多いです。

### 最小のPDF

以下は、最小の「Hello」という文字を表示するPDFの例です。

```text
%PDF-1.7

1 0 obj
<< /Type /Catalog /Pages 2 0 R >>
endobj

2 0 obj
<< /Type /Pages /Kids [ 3 0 R ] /Count 1 >>
endobj

3 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [ 0 0 595 842 ] /Contents 4 0 R >>
endobj

4 0 obj
<< /Length 44 >>
stream
BT /F1 24 Tf 100 700 Td (Hello) Tj ET
endstream
endobj

xref
...
trailer
...
%%EOF
```

これを見てもパッとは分かりませんが、

1. `1 0 obj` の単位でオブジェクトが並ぶ
2. `2 0 R` の形式で参照が張られる

この 2 点を押さえると、PDF が謎のテキストの塊ではなく参照で繋がったデータ構造に見え始めてきます。

## PDFの構成

多くの PDF は、ざっくり次の 4 つのパートを持ちます（派生もあります）。

- Header：`%PDF-1.7` のようなバージョン情報
- Body：オブジェクト本体（ページ、フォント、画像など）
- xref：オブジェクトの位置を示す住所録（一種のポインタだと思ってもらって良いです）
- Trailer：`/Root`（入口はどれか）などの全体情報

重要なのは、入口（`/Root`）から参照を辿ると必要なものに到達できる点です。

### 追記更新で履歴が残ることがある

追記更新では、末尾に新しいオブジェクト群と xref・trailer を追加します。編集のたびに末尾へ積み増されます。  
過去の xref へは `trailer` の `/Prev` から辿れます。

### xref がストリームのこともある

PDF 1.5 以降では、xref が表ではなくストリームの場合があります。  
その形式だと `xref` というキーワードが見えないことがあります。代わりに `/Type /XRef` を持つストリームオブジェクトが登場します。

## Body は参照で繋がる

Body には間接オブジェクトが並んでいます。

- `3 0 obj` の `3` はオブジェクト番号
- `0` は世代番号（generation）
- `2 0 R` は `2 0 obj` への間接参照
- `<< ... >>` は辞書
- `[ ... ]` は配列
- `stream ... endstream` はストリーム

参照が多いので、見た目がフラットに見えるものの、組み立てなおすと実態はグラフ構造です。

## 参照を辿るとページツリーになる

PDF でまず押さえると良いのはページ周りです。典型的には次のように繋がります。

```mermaid
graph TD
  Root["Catalog (/Type /Catalog)"] --> Pages["Pages (/Type /Pages)"]
  Pages --> Page1["Page (/Type /Page)"]
  Page1 --> Resources["Resources (フォント/画像など)"]
  Page1 --> Contents["Contents (描画命令ストリーム)"]
```

ページ周りが木っぽく見えるのは、`/Pages` と `/Kids` がページツリーとして設計されているためです。  
ただし Resources は共有されることもあります。PDF 全体は木ではなくグラフです。

### Resources は継承されることがある

Page オブジェクトに `/Resources` が無い場合があります。  
このケースでは、親の `/Pages` から継承していることがあります。Page の中だけで判断しないのがコツです。

### Acrobat Proなどでオブジェクト構造は確認できる

Acrobat Proなどのビューアでは、PDFのオブジェクト構造を確認できます。例えば以下のような構造になっています。

![PDFのオブジェクト構造の例](/images/20251218-pdf-xml/acrobat.png)

## XML 風に再構成してみる

PDF をそのまま読むのは大変です。そこで参照を辿って、構造が分かる形に再構成します。

```xml
<pdf version="1.7">
  <catalog>
    <pages count="1">
      <page number="1" width="595" height="842">
        <resources>
          <font name="F1" />
        </resources>
        <contents>
          <text x="100" y="700" font="F1" size="24">Hello</text>
        </contents>
      </page>
    </pages>
  </catalog>
</pdf>
```

:::message
この XML は理解のための擬似表現です。Tagged PDF の構造ツリーとは別です。
:::

## Resources と Contents

PDF を読む上で重要なのは、素材置き場と描画命令が分かれている点です。

### Resources は素材に名前を付ける

Resources は、フォントや画像などに名前を付けます。  
たとえば「このページでは `F1` という名前でこのフォントを使う」といった具合です。

### Contents は命令を並べて描く

Contents は、描画命令を順番に並べます。  
たとえば「`F1` でこの座標に文字を書け」といった命令になります。

```xml
<page>
  <resources>
    <font name="F1" ref="FontObject_123" />
    <xobject name="Im1" ref="ImageObject_456" />
  </resources>
  <contents>
    <text font="F1" x="100" y="700">...</text>
    <drawImage ref="Im1" x="0" y="0" />
  </contents>
</page>
```

### なぜ分かれているのか

再利用性を高めるため、resourcesとcontentsに分かれています。  
例えば同じフォントを 100 ページで使うなら、フォント本体を 1 回だけ持ち、各ページは参照だけで済ませたいはずです。

## Contents は文章ではなく描画命令

Contents の中身はコンテンツストリームです。内部には描画命令（オペレータ）が並びます。

### テキスト描画の例

```text
BT              % テキストオブジェクト開始
/F1 24 Tf       % フォントF1、サイズ24
100 700 Td      % 位置移動
(Hello) Tj      % 文字列を描画
ET              % テキストオブジェクト終了
```

ここで大事なのは、PDF が基本的に意味ではなく見た目を記述している点です。

- HTML は「これは段落」などの意味を持つ
- PDF は「この座標にこれを描け」で見た目を作る

見た目の再現性は高い一方で、文章として扱うのは得意ではありません。今回は余談ですが、文章構造をPDFに残しておくために、メタデータとして別途XMLをPDF内で保持するような仕組みもあります。

## よくある現象を説明できるようになる

### OCR 済み PDF で選択できる文字がある理由

OCR 済み PDF は次の構成になることが多いです。

1. ページ全面のスキャン画像を貼る
2. その上に OCR 結果のテキストを不可視で重ねる（選択はできる）

```xml
<contents>
  <drawImage ref="ScanImage" x="0" y="0" width="595" height="842" />
  <text x="120" y="700" textRenderingMode="3">請求書</text>
</contents>
```

PDF の命令列では、テキスト描画モードを不可視にする指定（例：`3 Tr`）で実現されることが多いです。余談ですが、最近このように透明な文字を大学の講義資料に埋め込むことで、AIに直接PDFを読ませて資料内の課題を直接回答させた際、埋め込まれたAI活用方法にだけ読める不可視文字によって明後日の回答をさせるような事例もありました。

https://ledge.ai/articles/invisible_prompt_ai_trap_keio

#### 選択範囲がズレる理由

ズレの原因は座標の話であることが多いです。たとえば次の要因があります。

- OCR の推定位置がずれている
- ページ回転（`/Rotate`）が入っている
- 座標変換（`cm`）が入っている
- 画像の縮尺とテキスト座標の縮尺が噛み合わない

### 黒塗りしたのにコピーできる・データが残っている

黒い四角を上から被せるだけだと、下のテキストは残ります。

```xml
<contents>
  <text x="100" y="700">社外秘</text>
  <rectangle x="100" y="700" width="200" height="30" fill="black" />
</contents>
```

描画はレイヤーの上に上に重ねられるので見た目は隠れます。  
しかしデータは残るので、抽出できることがあります。

追記更新が絡むと厄介になります。ツールによっては、削除したつもりの元データが過去の状態として残ることがあります。

:::message alert
データを完全に削除するのが目的なら、上から塗る方法は避けたほうが安全です。  
AcrobatなどのPDF viewerにある墨消し機能などで元データを削除してください。これによって、そもそもテキストのオブジェクトごと削除しつつ、そこに黒いオブジェクトなどを配置してくれます。
:::

### テキスト抽出すると順番がバラバラになる理由

PDF は座標指定で描画します。ファイル内の命令の順番と、見た目の上下は一致しません。

さらに文章っぽさが失われる理由もあります。

- 1 文字ずつ別々に描画することがある
- 空白は座標移動で表現されることがある
- `TJ` で文字間隔を細かく調整することがある
- 表は罫線と文字の寄せ集めとして描かれることが多い

そのため、単純に上から読む前提で抽出すると崩れやすくなります。

## そして深淵へ

ここまでの XML 風表現では `<text>Hello</text>` のように書きました。  
ただ、PDF の中の `(Hello)` は Unicode 文字列とは限りません。実体としては文字コード（バイト列）です。

レンダリングはフォントの対応関係で描けます。  
一方で「このバイト列は Unicode として何か」を確実に言えるかは別問題です。

その結果、次のような現象が起きます。

- コピペすると文字化けする
- 検索できない
- 同じ見た目でも抽出結果が違う

:::details もう少しだけ正確に（ToUnicode とか）
PDF のテキストはコンテンツストリーム中の文字列として現れます。  
ただし実体は character codes の並びです。

Unicode に落ちるかどうかは、主に次の要素に依存します。

- フォントの種類（単純フォント / Type0 など）
- フォント辞書に `ToUnicode` CMap があるか
- サブセット化などで対応関係が失われていないか

`ToUnicode` が適切に入ると、ビューアは抽出時に正しく Unicode へ変換しやすくなります。  
`ToUnicode` が無い場合、ビューアは推測するしかありません。結果としてコピペが壊れることがあります。

Tagged PDF（構造ツリー）が入ると読み上げやリフローに役立つことがあります。  
ただし、すべての PDF に入るわけではありません。
:::

## PDF の仕様についてもっと知りたくなったら

仕様レベルで確認したい方向けのメモです。

- PDF 1.7 は ISO 32000-1:2008
- PDF 2.0 は ISO 32000-2:2020（PDF Association 経由で無償入手できます）

読むのが大変な場合は、次の観点から拾うと繋がりやすいです。

- 辞書 / 配列 / ストリーム（基本データ型）
- ページツリー（`/Catalog` → `/Pages` → `/Page`）
- コンテンツストリームのオペレータ（`BT/ET/Tj/TJ/cm/Do` など）
- フォントと `ToUnicode`
- xref（テーブルとストリーム）
- 追記更新（`/Prev` チェーン）

### 資料

PDFインフラストラクチャ解説 電子の紙PDFとその周辺技術を語り尽す 第1.1版
https://web.antenna.co.jp/shop/html/products/detail.php?product_id=836

PDF構造解説
https://www.oreilly.co.jp/books/9784873115498/

仕様書（原本）
https://pdfa.org/resource/pdf-specification-index/

チートシート
https://pdfa.org/resource/pdf-cheat-sheets/

## おわりに

PDF を XML 風に表して、内部構造と現象を繋げてみました。  
ここまでの前提が入ると、OCR や黒塗り、抽出の違和感が仕様的にそうなるへ寄っていくはずです。

もし需要があれば、フォントと ToUnicode のさらに深い話や、PDF から文字をちゃんと読み取る実装の苦労もまとめたいと思っています。

お読みいただきありがとうございました。
